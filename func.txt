access - проверяет, имеет ли процесс права на чтение или запись, 
или же просто проверяет, существует ли файл (или другой объект файловой системы), 
с именем pathname. Если pathname является символьной ссылкой, 
то проверяются права доступа к файлу, на который она ссылается.

В случае успеха (есть все запрошенные права) возвращается нуль. 
При ошибке (по крайней мере один запрос прав из mode был неудовлетворен, 
или случилась другая ошибка), возвращается -1, а errno устанавливается должным образом.  

int access(const char *pathname, int mode);


open - кладем в него файл, а он отдает типа "трекер" к этому файлу который мы в дальнейшем
можем использовать, чтобы обрыщаться к этому файлу

возвращают новый описатель файла или -1 в случае ошибки

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);


unlink - удаляет имя из файловой системы. Если это имя было последней ссылкой на файл 
и больше нет процессов, которые держат этот файл открытым, данный файл удаляется и место, 
которое он занимает освобождается для дальнейшего использования.

В случае успеха возвращается ноль. 
В случае ошибки возвращается -1 и значение errno устанавливается соответствующим образом.  

int unlink(const char *pathname); 


close - используется после функции ОПЕН, чтобы закрыть "трекер"

возвращает ноль при успешном завершении или -1, если произошла ошибка.  

int close(int fd);


read - старается читать файл по "трекеру" в указанную строку, по заданное кол-во байт "count"

При успешном завершении вызова возвращается количество байтов, 
которые были считаны (нулевое значение означает конец файла), 
а позиция файла увеличивается на это значение

ssize_t read(int fd, void *buf, size_t count);


write - пишет по трекеру, раньше использовал для вывода на терминале, а можно и в файл. Лол

В случае успешного завершения возвращается количество байтов, 
которые были записаны (ноль означает, что не было записано ни одного байта). 
В случае ошибки возвращается -1, а переменной errno присваивается соответствующее значение

ssize_t write(int fd, const void *buf, size_t count); 


waitpid - Функция waitpid приостанавливает выполнение текущего процесса до тех пор, 
пока дочерний процесс, указанный в параметре pid, не завершит выполнение, 
или пока не появится сигнал, который либо завершает текущий процесс 
либо требует вызвать функцию-обработчик. Если указанный дочерний процесс к моменту вызова 
функции уже завершился (так называемый "зомби"), то функция немедленно возвращается. 
Системные ресурсы, связанные с дочерним процессом, освобождаются. 
Параметр pid может принимать несколько значений:

Возвращает идентификатор дочернего процесса, который завершил выполнение, или ноль, 
если использовался WNOHANG и ни один дочерний процесс пока еще недоступен, 
или -1 в случае ошибки (в этом случае переменной errno присваивается соответствующее значение).  

pid_t waitpid(pid_t pid, int *status, int options); 


wait - приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс 
не завершится, или до появления сигнала, который либо завершает текущий процесс, 
либо требует вызвать функцию-обработчик. Если дочерний процесс к моменту вызова функции 
уже завершился (так называемый "зомби" ("zombie")), то функция немедленно возвращается. 
Системные ресурсы, связанные с дочерним процессом, освобождаются.

pid_t wait(int *status);


pipe - создает пару файловых описателей, указывающих на запись inode именованного канала, 
и помещает их в массив, на который указывает filedes. filedes[0] 
предназначен для чтения, а filedes[1] предназначен для записи.  

При удачном завершении вызова возвращаемое значение равно нулю. 
При ошибке возвращается -1, а переменной errno присваивается номер ошибки.

int pipe(int filedes[2]);  


dup - использует самый маленький свободный номер дескриптора.

int dup(int oldfd);


dup2 - делает newfd копией oldfd, закрывая newfd, если требуется.  

int dup2(int oldfd, int newfd);

dup и dup2 возвращают новый дескриптор или -1, если произошла ошибка


execve -  выполняет программу, заданную параметром filename. 
Программа должна быть или двоичным исполняемым файлом, или скриптом, 
начинающимся со строки вида "#! интерпретатор [аргументы]". 
В последнем случае интерпретатор -- это правильный путь к исполняемому файлу, 
который не является скриптом; этот файл будет выполнен как интерпретатор [arg] filename.

При успешном завершении execve() не возвращает управление, 
при ошибке возвращается -1, а значение errno устанавливается должным образом.

int execve(const char *filename, char *const argv [], char *const envp[]);


fork - создает процесс-потомок, который отличается от родительского только значениями PID 
(идентификатор процесса) и PPID (идентификатор родительского процесса), 
а также тем фактом, что счетчики использования ресурсов установлены в 0. 
Блокировки файлов и сигналы, ожидающие обработки, не наследуются.

При успешном завершении родителю возвращается PID процесса-потомка, 
а процессу-потомку возвращается 0. При неудаче родительскому процессу возвращается -1, 
процесс-потомок не создается, а значение errno устанавливается должным образом.  

pid_t fork(void);  


perror - пишет ошибки в  стандартный поток ошибки сообщения. 
Выводится строка s, затем двоеточие, пробел и сообщение, завершающееся переводом строки. 
Для большего удобства параметы строки должны содержать имя функции, вызвавшей ошибку.

void perror(const char *s);


strerror - возвращает строку, описывающую код ошибки, переданный в аргументе errnum, 
возможно с учетом категории LC_MESSAGES текущей локали для выбора соответсвующего языка. 
Приложение не должно изменять строку. Строка может измениться при последующем вызовом 
perror() или strerror(). В библиотеке нет функций изменяющих эту строку.

Возвращает соответсвующее описание ошибки или сообщение о том, что ошибка неизвестна. 
Значение errno при удачном вызове не меняется, а при ошибке устанавливается в 
ненулевое значение. Функция strerror_r() возвращает 0 при успешном завершении 
и -1 при ошибке, устанавливая при этом errno.

char *strerror(int errnum);


exit - приводит к обычному завершению программы, и величина status & 0377 
возвращается процессу-родителю (см. wait(2)). Все функции, зарегистрированные 
с помощью atexit() и on_exit(), вызываются в порядке, обратном порядку регистрации. 
Все данные всех открытых потоков сохраняются и потоки закрываются. 
Файлы, созданные функцией tmpfile() удаляются.

void exit(int status);